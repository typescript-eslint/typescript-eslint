---
authors: joshuakgoldberg
description: How typescript-eslint expands on TypeScript's type safety to catch explicit and implicit `any`s.
slug: catching-any
tags: [any, no-explicit-any, no-unsafe, noImplicitAny, typed linting]
title: 'Catching `any`s with Linting and TypeScript'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

TypeScript's `any` type is, by design, the single most unsafe part of its type system.
The `any` type indicates a type that can be anything and can be used in place of any other type.
Using `any` is unsafe because the type disables many of TypeScript's type-checking features and hampers its ability to provide developer assistance.
`any` is almost always meant to be used as a temporary placeholder until a more precise type is known.

TypeScript includes a [`noImplicitAny`](https://www.typescriptlang.org/tsconfig/#noImplicitAny) flag that causes TypeScript to report when a better type than `any` can't be inferred for a value.
`noImplicitAny` is part of its family of [`strict` compiler options](https://www.typescriptlang.org/tsconfig/#strict) and is generally recommended for all projects.

However, even with `noImplicitAny` enabled, it's common for the `any` type to sneak into codebases.
Developers have a habit of using `any` when they're unable to find a better type.
Even if a project never explicitly uses the `any` type, some APIs such as the built-in `JSON.stringify` or types such as `Function` can sneakily introduce the `any` type.

typescript-eslint includes several lint rules that help prevent unsafe practices due to the `any` type.
These rules flag uses of `any` or code patterns that sneakily introduce it.

## Banning Unsafe Types

The first line of defense against `any` for many repositories is adding lint rules that report on explicit uses of unsafe types.
Developers can always [disable ESLint rules with inline comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1), so this isn't guaranteed to prevent explicit `any`s from popping up.
But these lint rules put an immediate restriction on unsafe types -- and help guide towards better alternatives.

### Banning Explicit `any`s

[`@typescript-eslint/no-explicit-any`](https://typescript-eslint.io/rules/no-explicit-any) reports on any instance of the `any` type written in source.
Doing so helps prevent developers from using `any` instead of a more safe type.

Take the following unsafe declaration of `friend: any` in a `greet` function.
Because its `friend` parameter is typed as `any` instead of `string`, TypeScript won't report a type error on a call that provides another type.
`@typescript-eslint/no-explicit-any` would report on that `any`:

```ts
function greet(friend: any) {
  //                   ~~~
  // eslint(@typescript-eslint/no-explicit-any):
  // Unexpected any. Specify a different type.
  console.log(`Hello, ${friend.toUpperCase()}!`);
}

greet('Lazlo'); // Ok

greet({ name: 'Nadya' }); // Should be a type error, but isn't
```

Instead of `any`, it would have been more type safe to give `friend` the more precise type `string`.

### Banning `Function`

[`@typescript-eslint/no-unsafe-function-type`](https://typescript-eslint.io/rules/no-unsafe-function-type) reports on any instance of the built-in `Function` type written in source code.
`Function` is a loose, unsafe type: it allows being called with any number of arguments and returns type `any`.

Take the following version of `greet` that takes in a function for its parameter.
`Function` doesn't describe any parameter or return types, so TypeScript can't know what types it's meant to take in or return.
`@typescript-eslint/no-unsafe-function-type` would report on that `Function`:

```ts
function greet(getFriend: Function) {
  //                      ~~~~~~~~
  // eslint(@typescript-eslint/no-unsafe-function-type):
  // The `Function` type accepts any function-like value.
  // Prefer explicitly defining any function parameters and return type.
  console.log(`Hello, ${getFriend().toUpperCase()}!`);
}

greet(() => 'Lazlo'); // Ok

greet(() => ({ name: 'Nadya' })); // Should be a type error, but isn't
```

Instead of `Function`, it would have been more type safe to give `getFriend` the more precise type `() => string`.

### Enforcing `unknown` for Caught Exceptions

There is no `throws` keyword or other way to enforce types of exceptions in TypeScript[^no-throws], so their types can only be declared as `any` or `unknown`.
Caught exceptions in `catch` blocks and `Promise` rejections are, by default, typed as `any` in TypeScript.
TypeScript's [`useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig/#useUnknownInCatchVariables) changes `catch` block exceptions to `unknown`, but no compiler option equivalent exists for `Promise` rejections.

[`@typescript-eslint/use-unknown-in-catch-callback-variable`](https://typescript-eslint.io/rules/use-unknown-in-catch-callback-variable) enforces always using the unknown type for the parameter of a Promise rejection callback.

For example, given the following code, TypeScript would not report a type error, but the lint rule would report:

```ts
function rejectWith(value: string) {
  return Promise.reject(value);
}

rejectWith('Nandor').catch(error => {
  //                       ~~~~~
  // eslint(@typescript-eslint/use-unknown-in-catch-callback-variable):
  // Prefer the safe `: unknown` for a `catch` callback variable.

  console.log(error.message); // Should be a type error, but isn't
});
```

Had the `error` been given a `: unknown` type, TypeScript would be able to report on `error.message` as being unsafe.

## Banning Usage of Unsafe Types

Once an `any` type exists in code, it is "infectious": it can turn the types of values based on it into more `any`s.
typescript-eslint includes a collection of rules that flag code patterns which spread or are generally made less safe due to an `any`.

### Banning Unsafe Arguments

[`@typescript-eslint/no-unsafe-argument`](https://typescript-eslint.io/rules/no-unsafe-argument) reports on passing an `any` typed value to a function call.

For example, given some value returned as `any` by `JSON.parse`, the rule would report on it being passed to a function with a more precise parameter type:

```ts
declare function greet(friend: string): void;

function greetFromData(raw: string) {
  greet(JSON.parse(raw));
  //    ~~~~~~~~~~~~~~~
  // eslint(@typescript-eslint/no-unsafe-argument):
  // Unsafe argument of type `any` assigned to a parameter of type `string`.
}
```

### Banning Unsafe Assignments

[`@typescript-eslint/no-unsafe-assignment`](https://typescript-eslint.io/rules/no-unsafe-assignment) reports on assigning an `any` typed value to a property or variable.

For example, given some value returned as `any` by `JSON.parse`, the rule would report on it being assigned to an object's property:

```ts
const person = {
  name: '(anonymous)',
};

function setNameFromData(raw: string) {
  person.name = JSON.parse(raw);
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~
  // eslint(@typescript-eslint/no-unsafe-argument):
  // Unsafe assignment of an `any` value.
}
```

### Banning Unsafe Calls

[`@typescript-eslint/no-unsafe-call`](https://typescript-eslint.io/rules/no-unsafe-call) reports on assigning an `any` typed value to a property or variable.

For example, given some value returned as `any` by `JSON.parse`, the rule would report on it being assigned to an object's property:

```ts
const person = {
  name: '(anonymous)',
};

function setNameFromData(raw: string) {
  person.name = JSON.parse(raw);
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~
  // eslint(@typescript-eslint/no-unsafe-argument):
  // Unsafe assignment of an `any` value.
}
```

### Banning Unsafe Member Accesses

[`@typescript-eslint/no-unsafe-member-access`](https://typescript-eslint.io/rules/no-unsafe-member-access)

### Banning Unsafe Returns

[`@typescript-eslint/no-unsafe-return`](https://typescript-eslint.io/rules/no-unsafe-return)

Each of those rules target a different unsafe practice around the `any` type

## Additional Helpers

### Disabling TypeScript Suppressions

The `any` type is not the only way to bypass TypeScript's type system.
Developers are also able to use inline TypeScript directives: `// @ts-expect-error` and `// @ts-ignore`.
Those inline comment directives cause TypeScript to ignore type errors on a line.
Disabling TypeScript on a per-line basis can sometimes be necessary in rare cases, but is always unsafe and almost never the right choice.

:::tip
`// @ts-expect-error` and `// @ts-ignore` are almost the same, except `// @ts-expect-error` will produce a new type error if its line doesn't already have one.
It's generally preferable to use `// @ts-expect-error` over `// @ts-ignore`.
:::

[`@typescript-eslint/ban-comment`](/rules/ban-ts-comment) can be used to report on cases where developers use TypeScript comment directives.
By default, the rule:

- Always reports on `@ts-ignore` and `@ts-nocheck` comment directives
- Reports on `@ts-expect-error` directives that don't have an explanatory comment description
- Requires explanatory comment descriptions contain at least 3 characters

For example, suppose `"@example/package"` exports a `process` function that should take in a `string` but whose types incorrectly indicate take in a `number`.
A `// @ts-expect-error` comment could be used to tell TypeScript to ignore the line:

<Tabs>
<TabItem value="❌ Incorrect">

```ts
import { process } from '@example/package';

// @ts-ignore
process('New York City');
```

</TabItem>
<TabItem value="✅ Correct">

```ts
import { process } from '@example/package';

// @ts-expect-error -- Pending updating the process types. See GH-1234.
process('New York City');
```

</TabItem>
</Tabs>

One the types for `@example/package` are fixed to no longer produce a type error, the comment directive will itself produce a type error asking to delete itself.

### ESLint Comments Plugin

### `ts-reset`

## Alternatives to `any`

### `unknown`

## Further Reading

[^no-throws]: [Why TypeScript Doesn't Include a `throws` Keyword](https://www.learningtypescript.com/articles/why-typescript-doesnt-include-a-throws-keyword)
