---
authors: kirkwaiblinger
description: fooooo
slug: promises
tags: []
title: Async, Promises, Thenables
---

We have a few fundamental principles

- Async code should only be used when needed
- Unhandled rejections are Bad.

This post covers

- [@typescript-eslint/await-thenable](/rules/await-thenable)
- [@typescript-eslint/no-floating-promises](/rules/no-floating-promises)
- [@typescript-eslint/no-misused-promises](/rules/no-misused-promises)
- [@typescript-eslint/prefer-promise-reject-errors](/rules/prefer-promise-reject-errors)
- [@typescript-eslint/promise-function-async](/rules/promise-function-async)
- [@typescript-eslint/return-await](/rules/return-await)

##

Imagine someone adds the following JS file in a code review.

```js
function doSomething() {
  // ...
}

function doSomethingElse() {
  // ...
}

function getSomeValue() {
  // ...
}

export function foo() {
  doSomething();
  doSomethingElse();
  return getSomeValue();
}
```

Do you spot anything wrong with this snippet? Me neither!
This is perfectly plausible code as written.

Now, let's reveal some implementations:

```js
function doSomething() {
  fetch('https://example.com', { method: 'POST' });
}

function doSomethingElse() {
  fetch('https://example.com', { method: 'PUT' });
}

function getSomeValue() {
  return fetch('https://example.com', { method: 'GET' });
}

export function foo() {
  doSomething();
  doSomethingElse();
  return getSomeValue();
}
```

Well, now I'm suspicious! Did the author really intend to kick off two write requests, and return the result of a read request?
Much more plausible is that they meant to kick off the write requests in parallel, and, after they're done, read the result to ensure it's correct.

How can we catch these errors that depend on the implementations of other functions?
The answer, [of course](./2024-09-30-typed-linting.md), is TypeScript types!

Let's take a look at what the linter tells us:

```ts
function doSomething() {
  // [@typescript-eslint/no-floating-promises]: Promises must be awaited, end
  // with a call to .catch, end with a call to .then with a rejection handler
  // or be explicitly marked as ignored with the `void` operator.
  fetch('https://example.com', { method: 'POST' });
}
```

Fair enough! We've just kicked off a task but not given anyone a way to know when it's finished.
We'd best return the `fetch` promise.

```ts
// [@typescript-eslint/promise-function-async]: Functions that return promises must be async.
function doSomething() {
  return fetch('https://example.com', { method: 'POST' });
}
```

Another complaint! Let's make that function `async`.
Not only is it now unambiguously clear in code review that this is async code,
the `async` keyword unlocks the `await` keyword.
And come to think of it, we'd better use that in order to make sure our request succeeded.

```ts
async function doSomething() {
  const res = await fetch('https://example.com', { method: 'POST' });
  return res.ok;
}
```

Following the linter complaints, we might end up in a state that looks like this:

```ts
async function doSomething() {
  const res = await fetch('https://example.com', { method: 'POST' });
  return res.ok;
}

async function doSomethingElse() {
  const res = await fetch('https://example.com', { method: 'PUT' });
  return res.ok;
}

async function getSomeValue() {
  const res = await fetch('https://example.com', { method: 'GET' });
  return res.text();
}

export async function foo() {
  // @typescript-eslint/no-floating-promises reports this line
  doSomething();
  // @typescript-eslint/no-floating-promises reports this line
  doSomethingElse();
  return getSomeValue();
}
```

And now we're at a point where we can actually fix the bug:

```ts
export async function foo() {
  // run these tasks in parallel
  const results = await Promise.all([doSomething(), doSomethingElse()]);
  // make sure they succeeded!
  if (!results.every(res => res)) {
    throw new Error('write requests failed!');
  }

  // validate the outcome
  return getSomeValue();
}
```

These are the benefits unlocked by our Promise rules.

Their purposes are roughly as follows. See the individual rule docs for much more detailed writeups on each:

- [@typescript-eslint/await-thenable](/rules/await-thenable): Ensure you don't `await` values that cannot be a promise
- [@typescript-eslint/no-floating-promises](/rules/no-floating-promises): Ensure that you don't forget to `await` statements that may need it.
- [@typescript-eslint/no-misused-promises](/rules/no-misused-promises): Similar to previous, but ensures you don't provide promises to locations that don't expect promises.
- [@typescript-eslint/prefer-promise-reject-errors](/rules/prefer-promise-reject-errors): Ensure that you follow best practices around error handling in `async` contexts.
- [@typescript-eslint/promise-function-async](/rules/promise-function-async): Ensure that you use `async` syntax.
- [@typescript-eslint/return-await](/rules/return-await): Prevent subtle control flow errors in `async` functions.

Sometimes, you're in a situation where you know that a promise is safe to float. For this reason we have the `typeOrValue` specifier format. `node:test`, `fastify`.
