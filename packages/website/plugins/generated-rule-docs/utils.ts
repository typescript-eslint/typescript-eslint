import type {
  RuleMetaData,
  RuleMetaDataDocs,
} from '@typescript-eslint/utils/ts-eslint';
import * as fs from 'fs';
import * as lz from 'lz-string';
import type * as mdast from 'mdast';
import * as path from 'path';
import type * as unist from 'unist';
import type { VFile } from 'vfile';

export const eslintPluginDirectory = path.resolve(
  path.join(__dirname, '../../../eslint-plugin'),
);

export const sourceUrlPrefix =
  'https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/';

/**
 * @param withComment Whether to include a full comment note.
 * @remarks `withComment` can't be used inside a JSON object which is needed for eslintrc in the playground
 */
export function getEslintrcString(
  extendsBaseRuleName: string,
  stem: string,
  withComment: boolean,
): string {
  return `{
"rules": {${
    withComment
      ? '\n    // Note: you must disable the base rule as it can report incorrect errors'
      : ''
  }
"${extendsBaseRuleName}": "off",
"@typescript-eslint/${stem}": "error"
}
}`;
}

export function convertToPlaygroundHash(eslintrc: string): string {
  return lz.compressToEncodedURIComponent(eslintrc);
}

export function getUrlForRuleTest(ruleName: string): string {
  for (const localPath of [
    `tests/rules/${ruleName}.test.ts`,
    `tests/rules/${ruleName}/`,
  ]) {
    if (fs.existsSync(`${eslintPluginDirectory}/${localPath}`)) {
      return `${sourceUrlPrefix}${localPath}`;
    }
  }

  throw new Error(`Could not find test file for ${ruleName}.`);
}

export type RuleMetaDataWithDocs = RuleMetaData<string> & {
  docs: RuleMetaDataDocs;
};

export function isRuleMetaDataDocs(
  meta: RuleMetaData<string> | undefined,
): meta is RuleMetaDataWithDocs {
  return !!meta?.docs;
}

export type VFileWithStem = VFile & {
  stem: string;
};

export function isVFileWithStem(file: VFile): file is VFileWithStem {
  return !!file.stem;
}

export function nodeIsCode(node: unist.Node): node is mdast.Code {
  return node.type === 'code';
}

export function nodeIsHeading(node: unist.Node): node is mdast.Heading {
  return node.type === 'heading';
}

export function nodeIsParent(node: unist.Node): node is unist.Parent {
  return 'children' in node;
}

// The first two may be autogenerated.
// Inserting one heading requires shifting all following ones.
export const requiredHeadingNames = [
  'How to Use',
  'Options',
  'When Not To Use It',
  'Related To',
] as const;

type HeadingName = (typeof requiredHeadingNames)[number];

export interface RequiredHeadingIndices {
  howToUse: number;
  options: number;
  whenNotToUseIt: number;
}

export function ensureRequiredHeadings(
  children: unist.Node[],
  meta: RuleMetaDataWithDocs,
): RequiredHeadingIndices {
  const headingIndices = requiredHeadingNames.map(text =>
    children.findIndex(
      (node: unist.Node): node is mdast.Heading =>
        nodeIsHeading(node) &&
        node.depth === 2 &&
        node.children.length === 1 &&
        node.children[0].type === 'text' &&
        node.children[0].value === text,
    ),
  );

  function insertIfMissing(name: HeadingName, insertionIndex?: number): void {
    const nameIndex = requiredHeadingNames.indexOf(name);

    if (headingIndices[nameIndex] === -1) {
      insertionIndex ??=
        headingIndices.find(existingIndex => existingIndex !== -1) ??
        children.length;

      children.splice(insertionIndex, 0, {
        children: [
          {
            type: 'text',
            value: name,
          },
        ],
        depth: 2,
        type: 'heading',
      } as mdast.Heading);

      headingIndices[nameIndex] = insertionIndex;

      for (let i = nameIndex + 1; i < headingIndices.length; i++) {
        if (headingIndices[i] !== -1) {
          headingIndices[i] += 1;
        }
      }
    }
  }

  insertIfMissing('Options');

  if (meta.docs.extendsBaseRule) {
    insertIfMissing('How to Use');
  }

  if (meta.docs.requiresTypeChecking) {
    insertIfMissing(
      'When Not To Use It',
      headingIndices[3] === -1 ? children.length : headingIndices[3],
    );
  }

  return {
    howToUse: headingIndices[0],
    options: headingIndices[1],
    whenNotToUseIt: headingIndices[2],
  };
}

export function spliceChildrenAndAdjustHeadings(
  children: unist.Node[],
  headingIndices: RequiredHeadingIndices,
  insertIndex: number,
  deleteCount: number,
  ...items: unist.Node[]
): void {
  children.splice(insertIndex, deleteCount, ...items);

  for (const [key, value] of Object.entries(headingIndices)) {
    if (value >= insertIndex) {
      headingIndices[key as keyof typeof headingIndices] += items.length;
    }
  }
}
