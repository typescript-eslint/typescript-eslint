import type * as mdast from 'mdast';
import type * as unist from 'unist';

import { nodeIsHeading } from './nodes';
import type { RuleMetaDataWithDocs } from './types';

// The first two may be autogenerated.
// Inserting one heading requires shifting all following ones.
export const requiredHeadingNames = [
  'How to Use',
  'Options',
  'When Not To Use It',
  'Related To',
] as const;

type HeadingName = (typeof requiredHeadingNames)[number];

export interface RequiredHeadingIndices {
  howToUse: number;
  options: number;
  whenNotToUseIt: number;
}

export function ensureRequiredHeadings(
  children: unist.Node[],
  meta: RuleMetaDataWithDocs,
): RequiredHeadingIndices {
  const headingIndices = requiredHeadingNames.map(text =>
    children.findIndex(
      (node: unist.Node): node is mdast.Heading =>
        nodeIsHeading(node) &&
        node.depth === 2 &&
        node.children.length === 1 &&
        node.children[0].type === 'text' &&
        node.children[0].value === text,
    ),
  );

  function insertIfMissing(name: HeadingName, insertionIndex?: number): void {
    const nameIndex = requiredHeadingNames.indexOf(name);

    if (headingIndices[nameIndex] === -1) {
      insertionIndex ??=
        headingIndices.find(existingIndex => existingIndex !== -1) ??
        children.length;

      children.splice(insertionIndex, 0, {
        children: [
          {
            type: 'text',
            value: name,
          },
        ],
        depth: 2,
        type: 'heading',
      } as mdast.Heading);

      headingIndices[nameIndex] = insertionIndex;

      for (let i = nameIndex + 1; i < headingIndices.length; i++) {
        if (headingIndices[i] !== -1) {
          headingIndices[i] += 1;
        }
      }
    }
  }

  insertIfMissing('Options');

  if (meta.docs.extendsBaseRule) {
    insertIfMissing('How to Use');
  }

  if (meta.docs.requiresTypeChecking) {
    insertIfMissing(
      'When Not To Use It',
      headingIndices[3] === -1 ? children.length : headingIndices[3],
    );
  }

  return {
    howToUse: headingIndices[0],
    options: headingIndices[1],
    whenNotToUseIt: headingIndices[2],
  };
}
