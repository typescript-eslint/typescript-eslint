// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[` 1`] = `
"Incorrect

const promise = new Promise((resolve, reject) => resolve('value'));
promise;
~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(() => {});
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

Promise.reject('value').catch();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

Promise.reject('value').finally();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

[1, 2, 3].map(async x => x + 1);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar, or explicitly marking the expression as ignored with the \`void\` operator.
"
`;

exports[` 2`] = `
"Correct

const promise = new Promise((resolve, reject) => resolve('value'));
await promise;

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(
  () => {},
  () => {},
);

Promise.reject('value').catch(() => {});

await Promise.reject('value').finally(() => {});

await Promise.all([1, 2, 3].map(async x => x + 1));
"
`;

exports[` 3`] = `
"Options: { "ignoreVoid": true }

async function returnsPromise() {
  return 'value';
}
void returnsPromise();

void Promise.reject('value');
"
`;

exports[` 4`] = `
"Options: { "ignoreIIFE": true }

await (async function () {
  await res(1);
})();

(async function () {
  await res(1);
})();
"
`;
