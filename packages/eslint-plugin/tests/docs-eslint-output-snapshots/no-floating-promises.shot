// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 1`] = `
"Incorrect

const promise = new Promise((resolve, reject) => resolve('value'));
promise;
~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(() => {});
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

Promise.reject('value').catch();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

Promise.reject('value').finally();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

[1, 2, 3].map(async x => x + 1);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar, or explicitly marking the expression as ignored with the \`void\` operator.
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 2`] = `
"Correct

const promise = new Promise((resolve, reject) => resolve('value'));
await promise;

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(
  () => {},
  () => {},
);

Promise.reject('value').catch(() => {});

await Promise.reject('value').finally(() => {});

await Promise.all([1, 2, 3].map(async x => x + 1));
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 3`] = `
"Options: { "ignoreVoid": true }

async function returnsPromise() {
  return 'value';
}
void returnsPromise();

void Promise.reject('value');
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 4`] = `
"Options: { "ignoreIIFE": true }

await (async function () {
  await res(1);
})();

(async function () {
  await res(1);
})();
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 5`] = `
"Incorrect
Options: {"allowForKnownSafePromises":[{"from":"file","name":"SafePromise"},{"from":"lib","name":"PromiseLike"},{"from":"package","name":"Bar","package":"bar-lib"}]}

type UnsafePromise = Promise<number> & { __linterBrands?: string };
let promise: UnsafePromise = Promise.resolve(2);
promise;
~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.
promise.finally();
~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 6`] = `
"Correct
Options: {"allowForKnownSafePromises":[{"from":"file","name":"SafePromise"},{"from":"lib","name":"PromiseLike"},{"from":"package","name":"Bar","package":"bar-lib"}]}

type SafePromise = Promise<number> & { __linterBrands?: string }; // promises can be marked as safe by using branded types
let promise: SafePromise = Promise.resolve(2);
promise;
promise.finally();
"
`;
