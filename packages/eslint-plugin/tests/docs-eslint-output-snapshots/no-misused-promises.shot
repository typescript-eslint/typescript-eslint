// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Validating rule docs no-misused-promises.mdx code examples ESLint output 1`] = `
"Incorrect
Options: { "checksConditionals": true }

const promise = Promise.resolve('value');

if (promise) {
    ~~~~~~~ Expected non-Promise value in a boolean conditional.
  // Do something
}

const val = promise ? 123 : 456;
            ~~~~~~~ Expected non-Promise value in a boolean conditional.

while (promise) {
       ~~~~~~~ Expected non-Promise value in a boolean conditional.
  // Do something
}
"
`;

exports[`Validating rule docs no-misused-promises.mdx code examples ESLint output 2`] = `
"Correct
Options: { "checksConditionals": true }

const promise = Promise.resolve('value');

// Always \`await\` the Promise in a conditional
if (await promise) {
  // Do something
}

const val = (await promise) ? 123 : 456;

while (await promise) {
  // Do something
}
"
`;

exports[`Validating rule docs no-misused-promises.mdx code examples ESLint output 3`] = `
"Incorrect
Options: { "checksVoidReturn": true }

[1, 2, 3].forEach(async value => {
                  ~~~~~~~~~~~~~~~~ Promise returned in function argument where a void return was expected.
  await fetch(\`/\${value}\`);
~~~~~~~~~~~~~~~~~~~~~~~~~~~
});
~

new Promise<void>(async (resolve, reject) => {
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promise returned in function argument where a void return was expected.
  await fetch('/');
~~~~~~~~~~~~~~~~~~~
  resolve();
~~~~~~~~~~~~
});
~

document.addEventListener('click', async () => {
  console.log('synchronous call');
  await fetch('/');
  console.log('synchronous call');
});
"
`;

exports[`Validating rule docs no-misused-promises.mdx code examples ESLint output 4`] = `
"Correct
Options: { "checksVoidReturn": true }

// for-of puts \`await\` in outer context
for (const value of [1, 2, 3]) {
  await doSomething(value);
}

// If outer context is not \`async\`, handle error explicitly
Promise.all(
  [1, 2, 3].map(async value => {
    await doSomething(value);
  }),
).catch(handleError);

// Use an async IIFE wrapper
new Promise((resolve, reject) => {
  // combine with \`void\` keyword to tell \`no-floating-promises\` rule to ignore unhandled rejection
  void (async () => {
    await doSomething();
    resolve();
  })();
});

// Name the async wrapper to call it later
document.addEventListener('click', () => {
  const handler = async () => {
    await doSomething();
    otherSynchronousCall();
  };

  try {
    synchronousCall();
  } catch (err) {
    handleSpecificError(err);
  }

  handler().catch(handleError);
});
"
`;

exports[`Validating rule docs no-misused-promises.mdx code examples ESLint output 5`] = `
"Incorrect
Options: { "checksSpreads": true }

const getData = () => fetch('/');

console.log({ foo: 42, ...getData() });
                          ~~~~~~~~~ Expected a non-Promise value to be spreaded in an object.

const awaitData = async () => {
  await fetch('/');
};

console.log({ foo: 42, ...awaitData() });
                          ~~~~~~~~~~~ Expected a non-Promise value to be spreaded in an object.
"
`;

exports[`Validating rule docs no-misused-promises.mdx code examples ESLint output 6`] = `
"Correct
Options: { "checksSpreads": true }

const getData = () => fetch('/');

console.log({ foo: 42, ...(await getData()) });

const awaitData = async () => {
  await fetch('/');
};

console.log({ foo: 42, ...(await awaitData()) });
"
`;
