// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Validating rule docs ban-types.mdx code examples ESLint output 1`] = `
"Incorrect

// use lower-case primitives for consistency
const str: String = 'foo';
           ~~~~~~ Don't use \`String\` as a type. Use string instead
const bool: Boolean = true;
            ~~~~~~~ Don't use \`Boolean\` as a type. Use boolean instead
const num: Number = 1;
           ~~~~~~ Don't use \`Number\` as a type. Use number instead
const symb: Symbol = Symbol('foo');
            ~~~~~~ Don't use \`Symbol\` as a type. Use symbol instead
const bigInt: BigInt = 1n;
              ~~~~~~ Don't use \`BigInt\` as a type. Use bigint instead

// use a proper function type
const func: Function = () => 1;
            ~~~~~~~~ Don't use \`Function\` as a type. The \`Function\` type accepts any function-like value.
                     It provides no type safety when calling the function, which can be a common source of bugs.
                     It also accepts things like class declarations, which will throw at runtime as they will not be called with \`new\`.
                     If you are expecting the function to accept certain arguments, you should explicitly define the function shape.

// use safer object types
const lowerObj: Object = {};
                ~~~~~~ Don't use \`Object\` as a type. Use object instead
const capitalObj: Object = { a: 'string' };
                  ~~~~~~ Don't use \`Object\` as a type. Use object instead
"
`;

exports[`Validating rule docs ban-types.mdx code examples ESLint output 2`] = `
"Correct

// use lower-case primitives for consistency
const str: string = 'foo';
const bool: boolean = true;
const num: number = 1;
const symb: symbol = Symbol('foo');
const bigInt: bigint = 1n;

// use a proper function type
const func: () => number = () => 1;

// use safer object types
const lowerObj: object = {};
const capitalObj: { a: string } = { a: 'string' };
"
`;
