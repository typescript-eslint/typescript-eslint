---
description: 'Disallow comparing an enum value with a non-enum value.'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘
>
> See **https://typescript-eslint.io/rules/no-unsafe-enum-comparison** for documentation.

The TypeScript compiler can be surprisingly lenient when working with enums.
While overt unsafety problems with enums were [resolved in TypeScript 5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#all-enums-are-union-enums), some logical pitfalls remain permitted:

1. Comparing an enum to its literal runtime value:

   ```ts
   enum Vegetable {
     Arugula = 0,
     Spinach = 1,
   }

   function makeSalad(vegetable: Vegetable) {
     switch (vegetable) {
       case 0:
         console.log('Making Arugula Salad');
         break;
       case 1:
         console.log('Making Spinach Salad');
         break;
     }
   }
   ```

   The above code will break if the enum values change...

   ```ts
   enum Vegetable {
     Arugula = 1,
     Spinach = 0,
   }

   makeSalad(Vegetable.Spinach); // Prints 'Making Arugula Salad'
   ```

   ...whereas the code would have continued to work if written without explicit reference to the enum values:

   ```ts
   function makeSalad(vegetable: Vegetable) {
     switch (vegetable) {
       case Vegetable.Arugula:
         console.log('Making Arugula Salad');
         break;
       case Vegetable.Spinach:
         console.log('Making Spinach Salad');
         break;
     }
   }
   ```

   Note that using this style of comparison also allows for better IDE support, such as the "Rename Symbol" feature.

2. Comparing an enum to a non-enum type:

   ```ts
   enum HandleAction {
     Open = 'OPEN',
     Close = 'CLOSE',
   }

   function handleAction(action: string) {
     if (action === HandleAction.Open) {
       openFile();
     } else if (action === HandleAction.Close) {
       closeFile();
     }
   }
   ```

   This pattern is extremely brittle.
   It will break without complaints from the compiler if the enum values change, as before, or if the caller makes a typo:

   ```ts
   handleAction('open'); // No error, but completely useless.
   ```

This rule enforces the proper enum semantics of referring to them by name and treating their values as implementation details.

## Examples

<Tabs>
<TabItem value="âŒ Incorrect">

```ts
enum Fruit {
  Apple,
}

declare let fruit: Fruit;

fruit === 0;
```

```ts
enum Vegetable {
  Asparagus = 'asparagus',
}

declare let vegetable: Vegetable;

vegetable === 'asparagus';

declare let anyString: string;

anyString === Vegetable.Asparagus;
```

</TabItem>
<TabItem value="âœ… Correct">

```ts
enum Fruit {
  Apple,
}

declare let fruit: Fruit;

fruit === Fruit.Apple;
```

```ts
enum Vegetable {
  Asparagus = 'asparagus',
}

declare let vegetable: Vegetable;

vegetable === Vegetable.Asparagus;
```

</TabItem>
</Tabs>

## When Not To Use It

If you don't mind enums being treated as a namespaced bag of values, rather than opaque identifiers, you likely don't need this rule.

Sometimes, you may want to ingest a value from an API or user input, then use it as an enum throughout your application.
While validating the input, it may be appropriate to disable the rule; use your judgement as to what makes sense in your application.
For example:

```ts
/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */
function toVegetable(vegetable: string): Vegetable {
  if (vegetable === Vegetable.Asparagus) {
    return Vegetable.Asparagus;
  } else if (vegetable === Vegetable.Broccoli) {
    return Vegetable.Broccoli;
  } /* etc */ else {
    throw new Error('Invalid vegetable');
  }
}
/* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */
```

Alternately, you might consider making use of a validation library like [Zod](https://zod.dev/?id=native-enums).
See further discussion of this topic in [#8557](https://github.com/typescript-eslint/typescript-eslint/issues/8557).

Finally, in the rare case of relying on an third party enums that are only imported as `type`s, it may be difficult to adhere to this rule.
You might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.
