---
description: 'Disallow passing a value-returning function in a position accepting a void function.'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> üõë This file is source code, not the primary documentation location! üõë
>
> See **https://typescript-eslint.io/rules/strict-void-return** for documentation.

## Rule Details

TypeScript considers functions returning a value to be assignable to a function returning void.
Using this feature of TypeScript can lead to bugs or confusing code.

## Examples

### Return type unsafety

Passing a value-returning function in a place expecting a void function can be unsound.
TypeScript generally treats the `void` type as though it has the same runtime behavior as `undefined`,
so this pattern will cause a mismatch between the runtime behavior and the types.

```ts
// TypeScript errors on overtly wrong ways of populating the `void` type...
function returnsVoid(): void {
  return 1234; // TS Error:  Type 'number' is not assignable to type 'void'.
}

// ...but allows more subtle ones
const returnsVoid: () => void = () => 1234;

// Likewise, TypeScript errors on overtly wrong usages of `void` as a runtime value...
declare const v: void;
if (v) {
  // TS Error: An expression of type 'void' cannot be tested for truthiness.
  // ... do something
}

// ...but silently treats `void` as `undefined` in more subtle scenarios
declare const voidOrString: void | string;
if (voidOrString) {
  // voidOrString is narrowed to string in this branch, so this is allowed.
  console.log(voidOrString.toUpperCase());
}
```

Between these two behaviors, examples like the following will throw at runtime, despite not reporting a type error:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
const getNothing: () => void = () => 2137;
const getString: () => string = () => 'Hello';
const maybeString = Math.random() > 0.1 ? getNothing() : getString();
if (maybeString) console.log(maybeString.toUpperCase()); // ‚ùå Crash if getNothing was called
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
const getNothing: () => void = () => {};
const getString: () => string = () => 'Hello';
const maybeString = Math.random() > 0.1 ? getNothing() : getString();
if (maybeString) console.log(maybeString.toUpperCase()); // ‚úÖ No crash
```

</TabItem>
</Tabs>

### Unhandled returned promises

If a callback is meant to return void, values returned from functions are likely ignored.
Ignoring a returned Promise means any Promise rejection will be silently ignored
or crash the process depending on runtime.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(async () => {
  const response = await fetch('https://api.example.com/');
  const data = await response.json();
  console.log(data);
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(() => {
  (async () => {
    const response = await fetch('https://api.example.com/');
    const data = await response.json();
    console.log(data);
  })().catch(console.error);
});
```

</TabItem>
</Tabs>

:::info
If you only care about promises,
you can use the [`no-misused-promises`](no-misused-promises.mdx) rule instead.
:::

:::tip
Use [`no-floating-promises`](no-floating-promises.mdx)
to also enforce error handling of non-awaited promises in statement positions.
:::

### Ignored returned generators

If a generator is returned from a void function it won't even be started.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(function* () {
  console.log('Hello');
  yield;
  console.log('World');
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
declare function takesCallback(cb: () => void): void;

takesCallback(() => {
  function* gen() {
    console.log('Hello');
    yield;
    console.log('World');
  }
  for (const _ of gen());
});
```

</TabItem>
</Tabs>

### Probable mistakes

Returning a value from a void function is likely a mistake on part of the programmer.
This rule will often warn you early when using a function in a wrong way.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
['Kazik', 'Zenek'].forEach(name => `Hello, ${name}!`);
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
['Kazik', 'Zenek'].forEach(name => console.log(`Hello, ${name}!`));
```

</TabItem>
</Tabs>

### Void context examples

Every expression has a contextual (expected) type computed by the TypeScript type system.
This rule will check expressions where the contextual type is a function returning void.

The following expressions are checked:

- Function arguments
- JSX attribute values
- Right-hand side of assignments
- Return values
- Object property values
- Array elements
- Class property values

<Tabs>
<TabItem value="‚ùå Incorrect">

```tsx
declare function takesCallback(cb: () => void): void;
declare function TakesCallback(props: { cb: () => void }): string;
declare let callback: () => void;
declare let returnsCallback: () => () => void;
declare let callbackObj: Record<string, () => void>;
declare let callbackArr: (() => void)[];

takesCallback(() => 'Hello');
<TakesCallback cb={() => 'Hello'} />;
callback = () => 'Hello';
returnsCallback = () => {
  return () => 'Hello';
};
callbackObj = {
  hello: () => 'Hello',
};
callbackArr = [() => 'Hello'];
```

</TabItem>
<TabItem value="‚úÖ Correct">

```tsx
declare function takesCallback(cb: () => void): void;
declare function TakesCallback(props: { cb: () => void }): string;
declare let callback: () => void;
declare let returnsCallback: () => () => void;
declare let callbackObj: Record<string, () => void>;
declare let callbackArr: (() => void)[];

takesCallback(() => console.log('Hello'));
<TakesCallback cb={() => console.log('Hello')} />;
callback = () => console.log('Hello');
returnsCallback = () => {
  return () => console.log('Hello');
};
callbackObj = {
  hello: () => console.log('Hello'),
};
callbackArr = [() => console.log('Hello')];
```

</TabItem>
</Tabs>

### Void context from overloads

This rule treats an any-returning callback argument as a void context,
if there exists another overload where it is typed as returning void.

This is required to correctly detect `addEventListener`'s callback as void callback,
because otherwise the call always resolves to the any-returning signature.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
/// <reference lib="dom" />

document.addEventListener('click', () => {
  return 'Clicked';
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
/// <reference lib="dom" />

document.addEventListener('click', () => {
  console.log('Clicked');
});
```

</TabItem>
</Tabs>

### Void context from base class

This rule enforces class methods which override a void method to also be void.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
class Foo {
  cb() {
    console.log('foo');
  }
}

class Bar extends Foo {
  cb() {
    super.cb();
    return 'bar';
  }
}
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
class Foo {
  cb() {
    console.log('foo');
  }
}

class Bar extends Foo {
  cb() {
    super.cb();
    console.log('bar');
  }
}
```

</TabItem>
</Tabs>

### Void context from implemented interfaces

This rule enforces class methods which implement a void method to also be void.

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts
interface Foo {
  cb(): void;
}

class Bar implements Foo {
  cb() {
    return 'cb';
  }
}
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts
interface Foo {
  cb(): void;
}

class Bar implements Foo {
  cb() {
    console.log('cb');
  }
}
```

</TabItem>
</Tabs>

## Options

### `allowReturnAny`

{/* insert option description */}

Additional incorrect code when the option is **disabled**:

<Tabs>
<TabItem value="‚ùå Incorrect">

```ts option='{ "allowReturnAny": false }'
declare function fn(cb: () => void): void;

fn(() => JSON.parse('{}'));

fn(() => {
  return someUntypedApi();
});
```

</TabItem>
<TabItem value="‚úÖ Correct">

```ts option='{ "allowReturnAny": false }'
declare function fn(cb: () => void): void;

fn(() => void JSON.parse('{}'));

fn(() => {
  someUntypedApi();
});
```

</TabItem>
</Tabs>

## When Not To Use It

Primitive values returned from void functions are usually safe.
If you don't care about returning them you can use [`no-misused-promises`](./no-misused-promises.mdx) instead.

In browser context, an unhandled promise will be reported as an error in the console.
It's a always a good idea to also show some kind of indicator on the page that something went wrong,
but if you are just prototyping or don't care about that, the default behavior might be acceptable.
In such case, instead of handling the promises and `console.error`ing them anyways, you can just disable this rule.

Similarly, the default behavior of crashing the process on unhandled promise rejection
might be acceptable when developing, for example, a CLI tool.
If your promise handlers simply call `process.exit(1)` on rejection,
you might as well not use this rule and rely on the default behavior.

## Related To

- [`no-misused-promises`](./no-misused-promises.mdx) - A subset of this rule which only cares about promises.
- [`no-floating-promises`](./no-floating-promises.mdx) - Warns about unhandled promises in _statement_ positions.
- [`no-confusing-void-expression`](./no-confusing-void-expression.mdx) - Disallows returning _void_ values.

## Further Reading

- [TypeScript FAQ - Void function assignability](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)
