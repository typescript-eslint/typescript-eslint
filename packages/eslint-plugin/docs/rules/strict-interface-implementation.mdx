---
description: 'Enforce classes are fully assignable to any interfaces they implement.'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘
>
> See **https://typescript-eslint.io/rules/strict-interface-implementation** for documentation.

TypeScript allows classes to implement interfaces even if the class's methods or properties have only partially overlapping types with the interface's equivalents.
This can lead to subtle bugs when instances of the class are used in contexts expecting the interface's type.

This rule enforces more strictly than TypeScript that if a class implements an interface, all methods and parameters on the class are fully assignable to each base interface equivalent.

## Examples

<Tabs>
<TabItem value="âŒ Incorrect">

```ts
interface NullableBox {
  value: string | undefined;
}

class ValueBox implements NullableBox {
  value: string;

  constructor(value: string) {
    this.value = value;
  }
}

const box: NullableBox = new ValueBox('...');

// Not allowed for a ValueBox, but allowed for NullableBox
box.value = undefined;
```

```ts
interface GetterAndSetter {
  getValue(): string | undefined;
  setValue(value: string | undefined): void;
}

class HasPrivateValue implements GetterAndSetter {
  #value: string | undefined;

  constructor(value: string) {
    this.#value = value;
  }

  getValue(): string | undefined {
    return this.#value;
  }

  setValue(value: string) {
    this.#value = value;
  }
}

const container: GetterAndSetter = new HasPrivateValue('...');

// Not allowed for a HasPrivateValue, but allowed for GetterAndSetter
container.setValue(undefined);
```

</TabItem>
<TabItem value="âœ… Correct">

```ts
interface NullableBox {
  value: string | undefined;
}

class ValueBox implements NullableBox {
  value: string | undefined;

  constructor(value: string | undefined) {
    this.value = value;
  }
}

const box: NullableBox = new ValueBox('...');

// Now is allowed for a ValueBox, as well as NullableBox
box.value = undefined;
```

```ts
interface GetterAndSetter {
  getValue(): string | undefined;
  setValue(value: string | undefined): void;
}

class HasPrivateValue implements GetterAndSetter {
  #value: string | undefined;

  constructor(value: string) {
    this.#value = value;
  }

  getValue(): string | undefined {
    return this.#value;
  }

  setValue(value: string | undefined) {
    this.#value = value;
  }
}

const container: GetterAndSetter = new HasPrivateValue('...');

// Now is allowed for a HasPrivateValue, as well as GetterAndSetter
container.setValue(undefined);
```

</TabItem>
</Tabs>

## When Not To Use It

If you intentionally use class polymorphism in a way that doesn't play well with stricter inheritance checking, this rule might get in your way.
For example, if you know the difference between "covariance" and "contravariance" and have strong opinions about them that differ from this rule, this rule might not be for you.

## Further Reading

- [TypeScript Handbook > Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
- [StackOverflow: Difference between Variance, Covariance, Contravariance, Bivariance and Invariance in TypeScript](https://stackoverflow.com/questions/66410115/difference-between-variance-covariance-contravariance-bivariance-and-invarian)
