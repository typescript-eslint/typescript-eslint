---
description: 'Require explicit type annotations for empty arrays assigned to variables.'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘
>
> See **https://typescript-eslint.io/rules/require-explicit-array-types** for documentation.

This rule requires explicit type annotations for empty arrays assigned to variables. When assigning an empty array to a variable, TypeScript cannot infer the element type. The inferred type depends on your TypeScript configuration:

- **With `noImplicitAny: false`** (default): Empty arrays are inferred as `any[]`, which allows any type to be pushed but loses type safety.
- **With `noImplicitAny: true`** (strict mode): Empty arrays are inferred as `never[]`, which prevents adding any elements and causes type errors. However, TypeScript still allows `const arr = []` without a type annotation; errors only appear when you try to use the array.

This rule requires explicit type annotations for empty arrays at declaration time to ensure type safety. If you intentionally want `never[]`, explicitly type it: `const arr: never[] = []`.

## Examples

<Tabs>
<TabItem value="âŒ Incorrect">

```ts
const arr = [];
const items = [];
let data = [];
var list = [];
```

</TabItem>
<TabItem value="âœ… Correct">

```ts
const arr: string[] = [];
const items: number[] = [];
let data: boolean[] = [];
var list: any[] = [];

// If you intentionally want never[], you can be explicit about it
// Placeholder that will be replaced later
const placeholder: never[] = [];

// Non-empty arrays don't require explicit types
const numbers = [1, 2, 3];
const strings = ['a', 'b'];

// Type assertions are also acceptable
const typedArr = [] as string[];
const typedItems = [] as number[];
```

</TabItem>
</Tabs>

## When Not To Use It

If you prefer to rely on TypeScript's type inference for empty arrays, or if you consistently use type assertions instead of type annotations, you can turn this rule off.
