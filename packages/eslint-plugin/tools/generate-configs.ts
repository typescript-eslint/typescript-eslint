import type {
  ClassicConfig,
  Linter,
  RuleModule,
  RuleRecommendation,
} from '@typescript-eslint/utils/ts-eslint';
import * as fs from 'fs';
import * as path from 'path';
import prettier from 'prettier';
import * as url from 'url';

import type RulesFile from '../src/rules';

// no need for us to bring in an entire dependency for a few simple terminal colors
const chalk = {
  dim: (val: string): string => `\x1B[2m${val}\x1B[22m`,
  green: (val: string): string => `\x1B[32m${val}\x1B[39m`,
  red: (val: string): string => `\x1B[31m${val}\x1B[39m`,
  blueBright: (val: string): string => `\x1B[94m${val}\x1B[39m`,
  gray: (val: string): string => `\x1B[90m${val}\x1B[39m`,
};

interface RulesObject {
  default: {
    default: typeof RulesFile;
  };
}

async function main(): Promise<void> {
  // TODO: Standardize & simplify these tools/* scripts once v6 is more stable
  // @ts-expect-error -- ts-node allows us to use import.meta
  const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

  const {
    default: { default: rules },
  } =
    // @ts-expect-error -- We don't support ESM imports of local code yet.
    (await import('../dist/rules/index.js')) as RulesObject;

  function addAutoGeneratedComment(code: string): string {
    return [
      '// THIS CODE WAS AUTOMATICALLY GENERATED',
      '// DO NOT EDIT THIS CODE BY HAND',
      '// SEE https://typescript-eslint.io/linting/configs',
      '//',
      '// For developers working in the typescript-eslint monorepo:',
      '// You can regenerate it using `yarn generate:configs`',
      '',
      code,
    ].join('\n');
  }

  const prettierConfig = await prettier.resolveConfig(__dirname);

  type LinterConfigRules = Record<string, ClassicConfig.RuleLevel>;

  interface LinterConfig extends ClassicConfig.Config {
    extends?: string[] | string;
    plugins?: string[];
  }

  const RULE_NAME_PREFIX = '@typescript-eslint/';
  const MAX_RULE_NAME_LENGTH = Object.keys(rules).reduce(
    (acc, name) => Math.max(acc, name.length),
    0,
  );
  const BASE_RULES_TO_BE_OVERRIDDEN = new Map(
    Object.entries(rules)
      .filter(([, rule]) => rule.meta.docs?.extendsBaseRule)
      .map(
        ([ruleName, rule]) =>
          [
            ruleName,
            typeof rule.meta.docs?.extendsBaseRule === 'string'
              ? rule.meta.docs?.extendsBaseRule
              : ruleName,
          ] as const,
      ),
  );
  const EXTENDS = ['./configs/base', './configs/eslint-recommended'];

  type RuleEntry = [string, RuleModule<string, readonly unknown[]>];

  const allRuleEntries: RuleEntry[] = Object.entries(rules).sort((a, b) =>
    a[0].localeCompare(b[0]),
  );

  interface RuleFilter {
    deprecated?: 'exclude';
    typeChecked?: 'exclude' | 'include-only';
    baseRuleForExtensionRule?: 'exclude';
    forcedRuleLevel?: Linter.RuleLevel;
  }

  /**
   * Helper function reduces records to key - value pairs.
   */
  function reducer(
    config: LinterConfigRules,
    [key, value]: RuleEntry,
    settings: RuleFilter = {},
  ): LinterConfigRules {
    if (settings.deprecated && value.meta.deprecated) {
      return config;
    }

    // Explicitly exclude rules requiring type-checking
    if (
      settings.typeChecked === 'exclude' &&
      value.meta.docs?.requiresTypeChecking === true
    ) {
      return config;
    }

    if (
      settings.typeChecked === 'include-only' &&
      value.meta.docs?.requiresTypeChecking !== true
    ) {
      return config;
    }

    const ruleName = `${RULE_NAME_PREFIX}${key}`;

    if (
      settings.baseRuleForExtensionRule !== 'exclude' &&
      BASE_RULES_TO_BE_OVERRIDDEN.has(key)
    ) {
      const baseRuleName = BASE_RULES_TO_BE_OVERRIDDEN.get(key)!;
      console.log(
        baseRuleName
          .padStart(RULE_NAME_PREFIX.length + baseRuleName.length)
          .padEnd(RULE_NAME_PREFIX.length + MAX_RULE_NAME_LENGTH),
        '=',
        chalk.green('off'),
      );
      config[baseRuleName] = 'off';
    }
    console.log(
      `${chalk.dim(RULE_NAME_PREFIX)}${key.padEnd(MAX_RULE_NAME_LENGTH)}`,
      '=',
      chalk.red('error'),
    );
    config[ruleName] = settings.forcedRuleLevel ?? 'error';

    return config;
  }

  /**
   * Helper function writes configuration.
   */
  async function writeConfig(
    getConfig: () => LinterConfig,
    name: string,
  ): Promise<void> {
    const hyphens = '-'.repeat(35 - Math.ceil(name.length / 2));
    console.log(chalk.blueBright(`\n${hyphens} ${name}.ts ${hyphens}`));

    // note: we use `export =` because ESLint will import these configs via a commonjs import
    const code = `export = ${JSON.stringify(getConfig())};`;
    const configStr = await prettier.format(addAutoGeneratedComment(code), {
      parser: 'typescript',
      ...prettierConfig,
    });
    fs.writeFileSync(
      path.resolve(__dirname, `../src/configs/${name}.ts`),
      configStr,
    );
  }

  interface ExtendedConfigSettings {
    extraExtends?: readonly string[];
    name: string;
    filters?: RuleFilter;
    ruleEntries: readonly RuleEntry[];
  }

  async function writeExtendedConfig({
    extraExtends = [],
    filters: ruleFilter,
    name,
    ruleEntries,
  }: ExtendedConfigSettings): Promise<void> {
    await writeConfig(
      () => ({
        extends: [...EXTENDS, ...extraExtends],
        rules: ruleEntries.reduce(
          (config, entry) => reducer(config, entry, ruleFilter),
          {},
        ),
      }),
      name,
    );
  }

  function filterRuleEntriesTo(
    ...recommendations: (RuleRecommendation | undefined)[]
  ): RuleEntry[] {
    return allRuleEntries.filter(([, rule]) =>
      recommendations.includes(rule.meta.docs?.recommended),
    );
  }

  await writeConfig((): LinterConfig => {
    const baseConfig: LinterConfig = {
      parser: '@typescript-eslint/parser',
      parserOptions: {
        sourceType: 'module',
      },
      plugins: ['@typescript-eslint'],
    };

    console.log(chalk.gray('Config values:'));

    const longestKey = Object.keys(baseConfig).reduce(
      (previous, next) => Math.max(previous, next.length),
      0,
    );
    for (const [key, value] of Object.entries(baseConfig)) {
      console.log(' ', key.padEnd(longestKey), value);
    }

    return baseConfig;
  }, 'base');

  await writeExtendedConfig({
    name: 'all',
    filters: {
      deprecated: 'exclude',
    },
    ruleEntries: allRuleEntries,
  });

  await writeExtendedConfig({
    filters: {
      typeChecked: 'exclude',
    },
    name: 'recommended',
    ruleEntries: filterRuleEntriesTo('recommended'),
  });

  await writeExtendedConfig({
    name: 'recommended-type-checked',
    ruleEntries: filterRuleEntriesTo('recommended'),
  });

  await writeExtendedConfig({
    filters: {
      typeChecked: 'exclude',
    },
    name: 'strict',
    ruleEntries: filterRuleEntriesTo('recommended', 'strict'),
  });

  await writeExtendedConfig({
    name: 'strict-type-checked',
    ruleEntries: filterRuleEntriesTo('recommended', 'strict'),
  });

  await writeExtendedConfig({
    filters: {
      typeChecked: 'exclude',
    },
    name: 'stylistic',
    ruleEntries: filterRuleEntriesTo('stylistic'),
  });

  await writeExtendedConfig({
    name: 'stylistic-type-checked',
    ruleEntries: filterRuleEntriesTo('stylistic'),
  });

  await writeConfig(
    () => ({
      parserOptions: {
        project: null,
        program: null,
      },
      rules: allRuleEntries.reduce(
        (config, entry) =>
          reducer(config, entry, {
            typeChecked: 'include-only',
            baseRuleForExtensionRule: 'exclude',
            forcedRuleLevel: 'off',
          }),
        {},
      ),
    }),
    'disable-type-checked',
  );
}

main().catch(error => {
  console.error(error);
});
