import type { TSESLint } from '@typescript-eslint/utils';
import chalk from 'chalk';
import * as fs from 'fs';
import * as path from 'path';
import prettier from 'prettier';
import * as url from 'url';

// @ts-expect-error -- ts-node allows us to use import.meta
const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

const {
  default: { default: rules },
} =
  // @ts-expect-error -- We don't support ESM imports of local code yet.
  (await import('../dist/rules/index.js')) as RulesObject;

function addAutoGeneratedComment(code: string): string {
  return [
    '// THIS CODE WAS AUTOMATICALLY GENERATED',
    '// DO NOT EDIT THIS CODE BY HAND',
    '// SEE https://typescript-eslint.io/docs/linting/configs',
    '//',
    '// For developers working in the typescript-eslint monorepo:',
    '// You can regenerate it using `yarn generate:configs`',
    '',
    code,
  ].join('\n');
}

const prettierConfig = prettier.resolveConfig.sync(__dirname);

interface LinterConfigRules {
  [name: string]:
    | TSESLint.Linter.RuleLevel
    | TSESLint.Linter.RuleLevelAndOptions;
}

interface LinterConfig extends TSESLint.Linter.Config {
  extends?: string | string[];
  plugins?: string[];
}

const RULE_NAME_PREFIX = '@typescript-eslint/';
const MAX_RULE_NAME_LENGTH = Object.keys(rules).reduce(
  (acc, name) => Math.max(acc, name.length),
  0,
);
const DEFAULT_RULE_SETTING = 'warn';
const BASE_RULES_TO_BE_OVERRIDDEN = new Map(
  Object.entries(rules)
    .filter(([, rule]) => rule.meta.docs?.extendsBaseRule)
    .map(
      ([ruleName, rule]) =>
        [
          ruleName,
          typeof rule.meta.docs?.extendsBaseRule === 'string'
            ? rule.meta.docs?.extendsBaseRule
            : ruleName,
        ] as const,
    ),
);
const EXTENDS = ['./configs/base', './configs/eslint-recommended'];

type RuleEntry = [
  string,
  TSESLint.RuleModule<string, unknown[], TSESLint.RuleListener>,
];

const ruleEntries: RuleEntry[] = Object.entries(rules).sort((a, b) =>
  a[0].localeCompare(b[0]),
);

interface ReducerSettings {
  errorLevel?: 'error' | 'warn';
  filterDeprecated?: boolean;
  filterTypeChecked?: 'include' | 'exclude';
}

/**
 * Helper function reduces records to key - value pairs.
 * @param config
 * @param entry
 * @param settings
 */
function reducer<TMessageIds extends string>(
  config: LinterConfigRules,
  entry: [string, TSESLint.RuleModule<TMessageIds, unknown[]>],
  settings: ReducerSettings,
): LinterConfigRules {
  const key = entry[0];
  const value = entry[1];

  if (settings.filterDeprecated && value.meta.deprecated) {
    return config;
  }

  // Explicitly exclude rules requiring type-checking
  if (
    settings.filterTypeChecked === 'exclude' &&
    value.meta.docs?.requiresTypeChecking === true
  ) {
    return config;
  }

  // Explicitly include rules requiring type-checking
  if (
    settings.filterTypeChecked === 'include' &&
    value.meta.docs?.requiresTypeChecking !== true
  ) {
    return config;
  }

  const ruleName = `${RULE_NAME_PREFIX}${key}`;
  const recommendation = value.meta.docs?.recommended;

  const usedSetting = settings.errorLevel
    ? settings.errorLevel
    : !recommendation
    ? DEFAULT_RULE_SETTING
    : recommendation === 'strict'
    ? 'warn'
    : recommendation;

  if (BASE_RULES_TO_BE_OVERRIDDEN.has(key)) {
    const baseRuleName = BASE_RULES_TO_BE_OVERRIDDEN.get(key)!;
    console.log(
      baseRuleName
        .padStart(RULE_NAME_PREFIX.length + baseRuleName.length)
        .padEnd(RULE_NAME_PREFIX.length + MAX_RULE_NAME_LENGTH),
      '=',
      chalk.green('off'),
    );
    config[baseRuleName] = 'off';
  }
  console.log(
    `${chalk.dim(RULE_NAME_PREFIX)}${key.padEnd(MAX_RULE_NAME_LENGTH)}`,
    '=',
    usedSetting === 'error'
      ? chalk.red(usedSetting)
      : chalk.yellow(usedSetting),
  );
  config[ruleName] = usedSetting;

  return config;
}

/**
 * Helper function writes configuration.
 */
function writeConfig(getConfig: () => LinterConfig, name: string): void {
  const hyphens = '-'.repeat(35 - Math.ceil(name.length / 2));
  console.log(chalk.blueBright(`\n${hyphens} ${name}.ts ${hyphens}`));

  // note: we use `export =` because ESLint will import these configs via a commonjs import
  const code = `export = ${JSON.stringify(getConfig())};`;
  const configStr = prettier.format(addAutoGeneratedComment(code), {
    parser: 'typescript',
    ...prettierConfig,
  });
  fs.writeFileSync(
    path.resolve(__dirname, `../src/configs/${name}.ts`),
    configStr,
  );
}

const recommendedValues = new Set<TSESLint.RuleRecommendation | undefined>([
  'error',
  'warn',
]);

function entryIsRecommended(entry: RuleEntry): boolean {
  return recommendedValues.has(entry[1].meta.docs?.recommended);
}

function entryIsStrict(entry: RuleEntry): boolean {
  return (
    entryIsRecommended(entry) || entry[1].meta.docs?.recommended === 'strict'
  );
}

function writeExtendedConfig(
  name: string,
  filter: (entry: RuleEntry) => boolean,
  reducerSettings: ReducerSettings,
): void {
  writeConfig(
    () => ({
      extends: EXTENDS,
      rules: ruleEntries
        .filter(filter)
        .reduce((config, entry) => reducer(config, entry, reducerSettings), {}),
    }),
    name,
  );
}

writeConfig((): LinterConfig => {
  const baseConfig: LinterConfig = {
    parser: '@typescript-eslint/parser',
    parserOptions: {
      sourceType: 'module',
    },
    plugins: ['@typescript-eslint'],
  };

  console.log(chalk.gray('Config values:'));

  const longestKey = Object.keys(baseConfig).reduce(
    (previous, next) => Math.max(previous, next.length),
    0,
  );
  for (const [key, value] of Object.entries(baseConfig)) {
    console.log(' ', key.padEnd(longestKey), value);
  }

  return baseConfig;
}, 'base');

writeExtendedConfig('all', () => true, {
  errorLevel: 'error',
  filterDeprecated: true,
});

writeExtendedConfig('recommended', entryIsRecommended, {
  filterTypeChecked: 'exclude',
});

writeExtendedConfig('recommended-type-checked', entryIsRecommended, {
  filterTypeChecked: 'include',
});

writeExtendedConfig('strict', entryIsStrict, {
  filterTypeChecked: 'exclude',
});

writeExtendedConfig('strict-type-checked', entryIsStrict, {
  filterTypeChecked: 'include',
});
