import type { TSESLint } from '@typescript-eslint/utils';
import chalk from 'chalk';
import * as fs from 'fs';
import * as path from 'path';
import prettier from 'prettier';
import * as url from 'url';

// @ts-expect-error -- ts-node allows us to use import.meta
const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

const {
  default: { default: rules },
} =
  // @ts-expect-error -- We don't support ESM imports of local code yet.
  (await import('../dist/rules/index.js')) as RulesObject;

function addAutoGeneratedComment(code: string): string {
  return [
    '// THIS CODE WAS AUTOMATICALLY GENERATED',
    '// DO NOT EDIT THIS CODE BY HAND',
    '// SEE https://typescript-eslint.io/linting/configs',
    '//',
    '// For developers working in the typescript-eslint monorepo:',
    '// You can regenerate it using `yarn generate:configs`',
    '',
    code,
  ].join('\n');
}

const prettierConfig = prettier.resolveConfig.sync(__dirname);

interface LinterConfigRules {
  [name: string]:
    | TSESLint.Linter.RuleLevel
    | TSESLint.Linter.RuleLevelAndOptions;
}

interface LinterConfig extends TSESLint.Linter.Config {
  extends?: string | string[];
  plugins?: string[];
}

const RULE_NAME_PREFIX = '@typescript-eslint/';
const MAX_RULE_NAME_LENGTH = Object.keys(rules).reduce(
  (acc, name) => Math.max(acc, name.length),
  0,
);
const BASE_RULES_TO_BE_OVERRIDDEN = new Map(
  Object.entries(rules)
    .filter(([, rule]) => rule.meta.docs?.extendsBaseRule)
    .map(
      ([ruleName, rule]) =>
        [
          ruleName,
          typeof rule.meta.docs?.extendsBaseRule === 'string'
            ? rule.meta.docs?.extendsBaseRule
            : ruleName,
        ] as const,
    ),
);
const EXTENDS = ['./configs/base', './configs/eslint-recommended'];

type RuleEntry = [
  string,
  TSESLint.RuleModule<string, unknown[], TSESLint.RuleListener>,
];

const allRuleEntries: RuleEntry[] = Object.entries(rules).sort((a, b) =>
  a[0].localeCompare(b[0]),
);

interface ruleFilter {
  deprecated?: 'exclude';
  typeChecked?: 'exclude';
}

/**
 * Helper function reduces records to key - value pairs.
 */
function reducer<TMessageIds extends string>(
  config: LinterConfigRules,
  entry: [string, TSESLint.RuleModule<TMessageIds, unknown[]>],
  settings: ruleFilter = {},
): LinterConfigRules {
  const key = entry[0];
  const value = entry[1];

  if (settings.deprecated && value.meta.deprecated) {
    return config;
  }

  // Explicitly exclude rules requiring type-checking
  if (
    settings.typeChecked === 'exclude' &&
    value.meta.docs?.requiresTypeChecking === true
  ) {
    return config;
  }

  const ruleName = `${RULE_NAME_PREFIX}${key}`;

  if (BASE_RULES_TO_BE_OVERRIDDEN.has(key)) {
    const baseRuleName = BASE_RULES_TO_BE_OVERRIDDEN.get(key)!;
    console.log(
      baseRuleName
        .padStart(RULE_NAME_PREFIX.length + baseRuleName.length)
        .padEnd(RULE_NAME_PREFIX.length + MAX_RULE_NAME_LENGTH),
      '=',
      chalk.green('off'),
    );
    config[baseRuleName] = 'off';
  }
  console.log(
    `${chalk.dim(RULE_NAME_PREFIX)}${key.padEnd(MAX_RULE_NAME_LENGTH)}`,
    '=',
    chalk.red('error'),
  );
  config[ruleName] = 'error';

  return config;
}

/**
 * Helper function writes configuration.
 */
function writeConfig(getConfig: () => LinterConfig, name: string): void {
  const hyphens = '-'.repeat(35 - Math.ceil(name.length / 2));
  console.log(chalk.blueBright(`\n${hyphens} ${name}.ts ${hyphens}`));

  // note: we use `export =` because ESLint will import these configs via a commonjs import
  const code = `export = ${JSON.stringify(getConfig())};`;
  const configStr = prettier.format(addAutoGeneratedComment(code), {
    parser: 'typescript',
    ...prettierConfig,
  });
  fs.writeFileSync(
    path.resolve(__dirname, `../src/configs/${name}.ts`),
    configStr,
  );
}

interface ExtendedConfigSettings {
  extraExtends?: string[];
  name: string;
  filters?: ruleFilter;
  ruleEntries: RuleEntry[];
}

function writeExtendedConfig({
  extraExtends = [],
  filters: ruleFilter,
  name,
  ruleEntries,
}: ExtendedConfigSettings): void {
  writeConfig(
    () => ({
      extends: [...EXTENDS, ...extraExtends],
      rules: ruleEntries.reduce(
        (config, entry) => reducer(config, entry, ruleFilter),
        {},
      ),
    }),
    name,
  );
}

function filterRuleEntriesTo(
  recommended: TSESLint.RuleRecommendation,
): RuleEntry[] {
  return allRuleEntries.filter(
    ([, rule]) => rule.meta.docs?.recommended === recommended,
  );
}

writeConfig((): LinterConfig => {
  const baseConfig: LinterConfig = {
    parser: '@typescript-eslint/parser',
    parserOptions: {
      sourceType: 'module',
    },
    plugins: ['@typescript-eslint'],
  };

  console.log(chalk.gray('Config values:'));

  const longestKey = Object.keys(baseConfig).reduce(
    (previous, next) => Math.max(previous, next.length),
    0,
  );
  for (const [key, value] of Object.entries(baseConfig)) {
    console.log(' ', key.padEnd(longestKey), value);
  }

  return baseConfig;
}, 'base');

writeExtendedConfig({
  name: 'all',
  filters: {
    deprecated: 'exclude',
  },
  ruleEntries: allRuleEntries,
});

writeExtendedConfig({
  filters: {
    typeChecked: 'exclude',
  },
  name: 'recommended',
  ruleEntries: filterRuleEntriesTo('recommended'),
});

writeExtendedConfig({
  name: 'recommended-type-checked',
  ruleEntries: filterRuleEntriesTo('recommended'),
});

writeExtendedConfig({
  filters: {
    typeChecked: 'exclude',
  },
  name: 'strict',
  ruleEntries: filterRuleEntriesTo('strict'),
});

writeExtendedConfig({
  name: 'strict-type-checked',
  ruleEntries: filterRuleEntriesTo('strict'),
});

writeExtendedConfig({
  filters: {
    typeChecked: 'exclude',
  },
  name: 'stylistic',
  ruleEntries: filterRuleEntriesTo('stylistic'),
});

writeExtendedConfig({
  name: 'stylistic-type-checked',
  ruleEntries: filterRuleEntriesTo('stylistic'),
});
